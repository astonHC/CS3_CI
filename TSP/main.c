// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// NESTED INCLUDES 

#include "tsp.h"

static int TSP_BEST_DIST;
static int TSP_BEST_PATH[TSP_MAX_CITIES + 1];

static const char* TSP_ERR[] =
{
    "OK",
    "INDEX OUT OF BOUNDS",
    "MAX CITIES EXCEEDED",
    "INVALID DISTANCE"
};

// INITIALISE THE ENCOMPASSING BASE FOR THE CURRENT TSP PROBLEM
// THE FOLLIWING WILL LOOK TO DETERMINE THE CITY COUNT, DISTANCES BETWEEN
// CITIES, ETC
//
// ENCORPERATES MATRIX ADDITION TO BE ABLE TO DETERMINE THE BASE
// DISTANCE BETWEEN CITIES
int TSP_INIT(TSP_STATE* STATE)
{
    if(STATE == NULL) { TSP_MEM_ERROR(STATE); }

    STATE->CITY_COUNT = 0;
    STATE->DIST.SIZE = 0;
    STATE->TOUR.TSP_TOTAL_DIST = TSP_MAX_CITIES;
    STATE->TOUR.TSP_CITY_COUNT = 0;

    memset(STATE, 0, sizeof(STATE));

    // NOW ITERATE THROUGH EACH OF THE MAX CITIES IN ACCORDANCE
    // WITH THE DISTANCE MATRIX BETWEEN THEM 
    for(int INDEX = 0; INDEX < TSP_MAX_CITIES; INDEX++)
    {
        for(int JINDEX = 0; JINDEX < TSP_MAX_CITIES; JINDEX++)
        {
            // HAVE WE REACHED THE MAX AMOUNT OF ITERATIONS?
            // THIS WAY, WE CAN DO A SAFER CHECK
            if(INDEX >= TSP_MAX_CITIES || JINDEX >= TSP_MAX_CITIES ||
                INDEX < 0 || JINDEX < 0)
            {
                goto TSP_OOB;
            }

            // ASSIGN THE CORRESPONDING VALUES TO EACH INDEX
            STATE->DIST.MATRIX[INDEX][JINDEX] = (INDEX == JINDEX) ? 0 : TSP_MAX_CITIES;
        }
    }

    return 0;

    TSP_OOB:
        TSP_ERROR_HANDLE(OOB, TSP_ERROR_OOB, "MAX CITY VALUE: %d", TSP_MAX_CITIES);
        return 1;
}

int main(void)
{
    TSP_STATE STATE;

    TSP_INIT(&STATE);

    printf("HARRY CLARK - CS3_CI TSP SOLUTION\n");
    return 0;
}
