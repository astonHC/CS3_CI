
// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// NESTED INCLUDES 

#include "tsp.h"

int TSP_BEST_DIST;
int TSP_BEST_PATH[TSP_MAX_CITIES + 1];

const char* TSP_ERR[] =
{
    "OK",
    "INDEX OUT OF BOUNDS",
    "MAX CITIES EXCEEDED",
    "INVALID DISTANCE"
};

// INITIALISE THE ENCOMPASSING BASE FOR THE CURRENT TSP PROBLEM
// THE FOLLIWING WILL LOOK TO DETERMINE THE CITY COUNT, DISTANCES BETWEEN
// CITIES, ETC
//
// ENCORPERATES MATRIX ADDITION TO BE ABLE TO DETERMINE THE BASE
// DISTANCE BETWEEN CITIES
int TSP_INIT(TSP_STATE* STATE)
{
    if(STATE == NULL) { TSP_MEM_ERROR(STATE); }

    STATE->CITY_COUNT = 0;
    STATE->DIST.SIZE = 0;
    STATE->TOUR.TSP_TOTAL_DIST = 0;
    STATE->TOUR.TSP_CITY_COUNT = 0;
    STATE->ALGO = TSP_NN;               // FORCE NN AS IT IS, QUITE FRANKLY, THE EASIEST

    // NOW ITERATE THROUGH EACH OF THE MAX CITIES IN ACCORDANCE
    // WITH THE DISTANCE MATRIX BETWEEN THEM 
    for(int INDEX = 0; INDEX < TSP_MAX_CITIES; INDEX++)
    {
        for(int JINDEX = 0; JINDEX < TSP_MAX_CITIES; JINDEX++)
        {
            // HAVE WE REACHED THE MAX AMOUNT OF ITERATIONS?
            // THIS WAY, WE CAN DO A SAFER CHECK
            if(!TSP_VALID_CITY(INDEX, TSP_MAX_CITIES) || 
                !TSP_VALID_CITY(JINDEX, TSP_MAX_CITIES))
            {
                goto TSP_OOB;
            }

            // ASSIGN THE CORRESPONDING VALUES TO EACH INDEX
            STATE->DIST.MATRIX[INDEX][JINDEX] = (INDEX == JINDEX) ? 0 : INT_MAX;
        }
    }

    return 0;

    TSP_OOB:
        TSP_ERROR_HANDLE(OOB, TSP_ERROR_OOB, "MAX CITY VALUE: %d", TSP_MAX_CITIES);
        return 1;
}

// ADD A CITY TO THE CURRENT ALGORITHM TYPE
int TSP_ADD_CITY(TSP_STATE* STATE, const char* NAME, int X, int Y)
{
    // CHECK IF WE HAVE EXCEEDED THE MAXIMUM AMOUNT OF CITIES
    if(!TSP_VALID_CITY(STATE->CITY_COUNT, TSP_MAX_CITIES)) goto TSP_CITY_MAX;

    // CREATE A NEW REPRESENTATION AND INDEX IT TO THE COUNT
    TSP_CITY* NEW_CITY = &STATE->CITY[STATE->CITY_COUNT];

    // COPY THAT CITY INTO THE BUFFER AND ASSIGN PARAMS
    strncpy(NEW_CITY->NAME, NAME, sizeof(NEW_CITY->NAME) - 1);

    // 29/09/25 - ADD PROPER NULL TERM FOR STRING ALLOC
    NEW_CITY->NAME[sizeof(NEW_CITY->NAME) - 1] = '\0';
    NEW_CITY->X = X;
    NEW_CITY->Y = Y;

    // NOW PRINT OUT THE CORRESPONDENCE FOR THE NEW CITY
    TSP_CITY_NAME(NAME, STATE->CITY_COUNT, X, Y);

    STATE->CITY_COUNT++;
    return 0;

    TSP_CITY_MAX:
        TSP_ERROR_HANDLE(CITY, TSP_ERROR_CITY, 
            "CURRENT CITY COUNT: %d\n", 
            STATE->CITY_COUNT);
}

// CALCULATES THE EUCLIDEAN DISTANCE BETWEEN EACH CITY
// THE COMMONALITY WITH THE TSP IS THAT WE ALWAYS PRESUPPOSE
// THAT EACH OF THE CITY ARE REPRESENTED BY PLANAR MAPPING
//
// WHICH MAKES ACCOUNTING FOR AXIS' A LOT EASIER 
int TSP_EUC_DIST(const TSP_CITY* CITY_A, const TSP_CITY* CITY_B) 
{
    int DIST_X = CITY_A->X - CITY_B->X;
    int DIST_Y = CITY_A->Y - CITY_B->Y;

    // FORCE TYPE CAST FOR DISTANCE
    // WE LEVERAGE INT FOR GREATER PRECISION
    // SQUARE ROOT HELPS WITH PRECISION MULTIPLICATION
    return (int)sqrt(DIST_X * DIST_X + DIST_Y * DIST_Y);
}

// CALCULATES THE DISTANCE MATRIX FOR ALL CITY PAIRS
// UTILISES MATRIX ADDITION TO INDEX THROUGH THE RESPECTIVE CITY COUNT
// AND DETERMINES THE DISTANCE BETWEEN THEM
void TSP_CALC_DIST(TSP_STATE* STATE)
{
    // DETERMINE THE DISTANCE SIZE BASED ON THE NUMBER OF CITIES
    // WHICH WILL GROW EXPONENTIALLY 
    STATE->DIST.SIZE = STATE->CITY_COUNT;

    for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
    {
        for(int ITERATOR = 0; ITERATOR < STATE->CITY_COUNT; ITERATOR++)
        {
            // IF ANY TWO CITIES ARE NOT THE SAME
            if(INDEX != ITERATOR)
            {
                STATE->DIST.MATRIX[INDEX][ITERATOR] = TSP_EUC_DIST(&STATE->CITY[INDEX], &STATE->CITY[ITERATOR]);
            }
            else
            {
                STATE->DIST.MATRIX[INDEX][ITERATOR] = 0;
            }
        }
    }
}

// TIME FOR THE ALGORITHM TYPES
// THE FOLLOWING WILL LOOK TO SOLVE FOR NEAREEST NEIGHBOUR

// WHICH LOOKS TO FIND THE MOST SIMILAR LIKENESS WITHIN A STRUCTURE
// IN THIS CASE, IT WILL LOOK FOR LIKEWISE PATTERNS TO APPROXIMATELY
// DETERMINE SPACING
int TSP_NEAREST(TSP_STATE* STATE) 
{
    int VISITED[TSP_MAX_CITIES] = {0};
    int CURRENT = 0;
    int DIST = 0;
    int PATH = 0;

    // FIRST DETERMINE THE CURRENT PATHING FROM THE CURRENT CITY
    // THEN CONFIRM WE HAVE VISITED
    STATE->TOUR.TSP_PATH[PATH++] = CURRENT;
    VISITED[CURRENT] = 1;

    for(int STEP = 1; STEP < STATE->CITY_COUNT; STEP++)
    {
        int NEAREST = -1;           // THE NEAREST WILL ALWAYS BE THE ONE INDEXXED CLOSER
        int NEAR_DIST = INT_MAX;    // WE WILL NEVER REACH INF

        // INDEX THROUGH ALL OF THE CITIES
        // DETERMINE IF WE HAVENT VISITED AND IF IT CLOSER THAN THE NEAREST
        for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
        {
            // VALIDATE AN EDGE CASE FOR SAFELY RETRIEVING VISIT
            int EDGE_DIST = STATE->DIST.MATRIX[CURRENT][INDEX];

            // THEN ADD THE INDEX TO THE "NOW CURRENT" NEAREST CITY
            // DO SO BY LEVERAGING THE SAFER PRE-PROC CHECK
            if(!VISITED[INDEX] && TSP_VALID_DIST(EDGE_DIST) && EDGE_DIST < NEAR_DIST)
            {
                NEAR_DIST = EDGE_DIST;
                NEAREST = INDEX;
            }
        }

        // NOW AFTER DETERMINING THE INDEX AGAINST THE NEAREST DISTANCE
        // WE CAN MAP THAT WE HAVE VISITED
        VISITED[NEAREST] = 1;
        STATE->TOUR.TSP_PATH[PATH++] = NEAREST;
        DIST += NEAR_DIST;
        CURRENT = NEAREST;
    }

    // NOW MAP THE DISTANCE COVERED TO THE MATRIX 
    DIST += STATE->DIST.MATRIX[CURRENT][0];

    STATE->TOUR.TSP_PATH[PATH] = 0;
    STATE->TOUR.TSP_TOTAL_DIST = DIST;
    STATE->TOUR.TSP_CITY_COUNT = STATE->CITY_COUNT;

    return 0;
}
