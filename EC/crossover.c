// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI EVOLUTIONARY COMPUTATION 

// THIS FILE PERTAINS TOWARDS AN EXAMPLE OF HOW UTILISING CROSSOVER
// ALLOWS FOR THE GRADUAL MUTATION/REPRODUCTION OF AN ALGORITHM OVER THE COURSE
// OF IT'S RUNTIME

// NESTED INCLUDES

#include "crossover.h"
#include "../EC_UTIL.h"

// CALCULATES THE COUNT MATCHING CHARACTERS AGAINST THE TARGET STRING
// THIS IS IN RELATION TO THE WELLNESS OF THE PERSON IN QUESTION
// THE WELLNESS WILL BE EXPANDED THROUGH THE EVOLUTION OF THE PROGRAM

int FITNESS_CALC(char* MATCH)
{
    int MATCHING_CHARS = 0;
    for(int INDEX = 0; INDEX < EC_STRLEN; INDEX++)
    {
        if(MATCH[INDEX] == EC_STRING[INDEX]) 
        { 
            MATCHING_CHARS++; 
        }
    }
    ERROR_TRACE(FITNESS, TRACE_OK, "FITNESS MATCH: %d", MATCHING_CHARS);
    return MATCHING_CHARS;
}

// CREATE A SINGLE POINT CROSSOVER WHICH CREATES TWO CHILDREN NODES 
// AGAINST THE PARENT
// THE CROSSOVER POINT IS THE POINT IN WHICH THE MUTATION WILL TAKE PLACE

int CROSS_SINGLE(char* PARENT_A, char* PARENT_B, char* CHILD_A, char* CHILD_B)
{
    int CROSS_POINT = 1 + rand() % (EC_STRLEN - 1);
    ERROR_TRACE(CROSS, TRACE_ERR_CROSSOVER, "SINGLE AT POINT %d", CROSS_POINT);

    // CREATE SUBSEQUENT NODES FOR CHILD USING MEMCPY FOR EFFICIENCY
    memcpy(CHILD_A, PARENT_A, CROSS_POINT);
    memcpy(CHILD_A + CROSS_POINT, PARENT_B + CROSS_POINT, EC_STRLEN - CROSS_POINT);

    memcpy(CHILD_B, PARENT_B, CROSS_POINT);
    memcpy(CHILD_B + CROSS_POINT, PARENT_A + CROSS_POINT, EC_STRLEN - CROSS_POINT);

    // ASSUME A NULL TERM CHARACTER TO AVOID SPILLOVERS
    CHILD_A[EC_STRLEN] = '\0';
    CHILD_B[EC_STRLEN] = '\0';

    return CROSS_POINT;
}

// CREATE A DOUBLE POINT CROSSOVER WHICH SWAPS SEGMENT BETWEEN TWO RANDOM POINTS
// THIS PROVIDES MORE GENETIC DIVERSITY THAN SINGLE POINT CROSSOVER

int CROSS_DOUBLE(char* PARENT_A, char* PARENT_B, char* CHILD_A, char* CHILD_B)
{
    int FIRST_POINT = rand() % EC_STRLEN;
    int SECOND_POINT = rand() % EC_STRLEN;

    if(FIRST_POINT > SECOND_POINT)
    {
        int TEMP = FIRST_POINT;
        FIRST_POINT = SECOND_POINT;
        SECOND_POINT = TEMP;
    }

    ERROR_TRACE(CROSS, TRACE_ERR_CROSSOVER, "DOUBLE BETWEEN %d AND %d", FIRST_POINT, SECOND_POINT);

    int SEGMENT_LENGTH = SECOND_POINT - FIRST_POINT + 1;

    // CREATE FIRST CHILD USING MEMCPY FOR EFFICIENT SEGMENT COPYING
    memcpy(CHILD_A, PARENT_A, FIRST_POINT);                                                         // FIRST SEGMENT
    memcpy(CHILD_A + FIRST_POINT, PARENT_B + FIRST_POINT, SEGMENT_LENGTH);                          // MIDDLE SEGMENT  
    memcpy(CHILD_A + SECOND_POINT + 1, PARENT_A + SECOND_POINT + 1, EC_STRLEN - SECOND_POINT - 1); // LAST SEGMENT

    // CREATE SECOND CHILD USING MEMCPY FOR EFFICIENT SEGMENT COPYING
    memcpy(CHILD_B, PARENT_B, FIRST_POINT);                                                         // FIRST SEGMENT
    memcpy(CHILD_B + FIRST_POINT, PARENT_A + FIRST_POINT, SEGMENT_LENGTH);                          // MIDDLE SEGMENT
    memcpy(CHILD_B + SECOND_POINT + 1, PARENT_B + SECOND_POINT + 1, EC_STRLEN - SECOND_POINT - 1); // LAST SEGMENT

    CHILD_A[EC_STRLEN] = '\0';
    CHILD_B[EC_STRLEN] = '\0';

    return SECOND_POINT - FIRST_POINT;
}

// RANDOMLY CHOOSE EACH GENE FROM EITHER PARENT
// THIS PROVIDES MAXIMUM GENETIC RECOMBINATION

void CROSS_UNI(char* PARENT_A, char* PARENT_B, char* CHILD_A, char* CHILD_B)
{
    ERROR_TRACE(CROSS, TRACE_ERR_CROSSOVER, "UNIFORM CROSSOVER");
    for(int INDEX = 0; INDEX < EC_STRLEN; INDEX++)
    {
        if(rand() % 2 == 0)
        {
            CHILD_A[INDEX] = PARENT_A[INDEX];
            CHILD_B[INDEX] = PARENT_B[INDEX];
        }
        else
        {
            CHILD_A[INDEX] = PARENT_B[INDEX];
            CHILD_B[INDEX] = PARENT_A[INDEX];
        }
    }
    CHILD_A[EC_STRLEN] = '\0';
    CHILD_B[EC_STRLEN] = '\0';
}

// ALLOWS DYNAMIC SWITCHING BETWEEN DIFFERENT CROSSOVER STRATEGIES

void CROSS_ALL(char* PARENT_A, char* PARENT_B, char* CHILD_A, char* CHILD_B, TYPE CROSS_TYPE)
{
    switch(CROSS_TYPE)
    {
        case SINGLE:
            CROSS_SINGLE(PARENT_A, PARENT_B, CHILD_A, CHILD_B);
            break;
        case DOUBLE:
            CROSS_DOUBLE(PARENT_A, PARENT_B, CHILD_A, CHILD_B);
            break;
        case UNIFORM:
            CROSS_UNI(PARENT_A, PARENT_B, CHILD_A, CHILD_B);
            break;
        default:
            ERROR_TRACE(CROSS, TRACE_ERR_CROSSOVER, "INVALID CROSSOVER TYPE: %d", CROSS_TYPE);
            CROSS_SINGLE(PARENT_A, PARENT_B, CHILD_A, CHILD_B);
            break;
    }
}

// INITIALIZE POPULATION WITH RANDOM CHROMOSOMES
// THIS WILL BE DETERMINED AGAINST TWO INDEXXES:

// - ONE THAT GOVERNS THE PEOPLE
// - THE OTHER THAT GOVERNS THE CHARACTERS WITHIN THE STRING WE ARE COMPARING AGAINST

void POPULATION_INIT(PERSON* POPULATION)
{
    for(int PERSON_INDEX = 0; PERSON_INDEX < EC_POP_SIZE; PERSON_INDEX++)
    {
        for(int CHARACTER_INDEX = 0; CHARACTER_INDEX < EC_STRLEN; CHARACTER_INDEX++)
        {
            POPULATION[PERSON_INDEX].CHROMOSOMES[CHARACTER_INDEX] = 46 + rand() % 100;
        }
        POPULATION[PERSON_INDEX].CHROMOSOMES[EC_STRLEN] = '\0';
        POPULATION[PERSON_INDEX].WELLBEING = FITNESS_CALC(POPULATION[PERSON_INDEX].CHROMOSOMES);
    }

    ERROR_TRACE(INIT, TRACE_ERR_GENERATION, "INITIALISED POOPULATION OF SIZE: %d", EC_POP_SIZE);
}

// CALCULATE THE FITNESS BASED ON THE OVERALL POPULATION
// THIS IS DIFFERENT TO THE ABOVE AS WE ARE LESS CONCERNED WITH THE
// STRING ITSELF BUT THE SIZE OF THE GENERATIONS

void POPULOUS_FITNESS(PERSON* POP, int SIZE)
{
    for (int INDEX = 0; INDEX < SIZE; INDEX++)
    {
        POP[INDEX].WELLBEING = FITNESS_CALC(POP[INDEX].CHROMOSOMES);
    }
}

// PRESERVE THE ELITES FROM THE GENERATION
// THOSE OF WHO PROVIDED THE MOST CONDUCIVE RESULT WILL BE CARRIED OVER

void PRESERVE_ELITE(PERSON* CURRENT, PERSON* NEW_POP, int ELITE)
{
    for (int INDEX = 0; INDEX < ELITE; INDEX++)
    {
        NEW_POP[INDEX] = CURRENT[INDEX];
    }
}

// GENERATE OFFSPRING AGAINST TWO PARENTS WHICH WILL BE INDEXXED
// BASED ON A START AND AN END TO DISCERN THE CHARACTERISTICS OF THE PARENTS

// THESE CHARACTERISTICS WILL BE THE DETERMINANTS IN THE RANDOM GENERATION OF 
// THEIR SUBSEQUENT FITNESS

void GEN_OFFSPRING(PERSON* CURRENT, PERSON* NEW_POP, int START, int END) 
{
    for (int INDEX = START; INDEX < END; INDEX += 2) 
    {
        if (rand() % 100 < EC_CRS_RATE) 
        {
            int PARENT_ONE = SELECTION(CURRENT);
            int PARENT_TWO = SELECTION(CURRENT);
            
            char CHILD_ONE[EC_CS];
            char CHILD_TWO[EC_CS];
            
            CROSS_ALL(
                CURRENT[PARENT_ONE].CHROMOSOMES,
                CURRENT[PARENT_TWO].CHROMOSOMES,
                CHILD_ONE,
                CHILD_TWO,
                CURRENT_CROSSOVER_METHOD
            );
            
            MUTATE(CHILD_ONE);
            MUTATE(CHILD_TWO);
            
            // COPY NEW MUTATIONS TO THE POPULATION
            // LEVERAGING STRCPY ESPECIALLY HELPS WITH BEING ABLE
            // TO INADVERTENTLY SPEED UP CONVERGENCE SPEEDS 

            // AS IT WILL ALWAYS PRESUPPOSE THAT THE PREVIOUS GENERIC MATERIAL
            // WILL BE PERFECTLY COPIED TO THE NEW

            strcpy(NEW_POP[INDEX].CHROMOSOMES, CHILD_ONE);
            NEW_POP[INDEX].WELLBEING = FITNESS_CALC(CHILD_ONE);
            
            // LOOK THROUGH ALL OF THE CONCURRENT ELEMENTS
            // WITHIN THE INDEXXED LIST OF THE NEW POPULATION

            if (INDEX + 1 < END) 
            {
                strcpy(NEW_POP[INDEX + 1].CHROMOSOMES, CHILD_TWO);
                NEW_POP[INDEX + 1].WELLBEING = FITNESS_CALC(CHILD_TWO);
            }
        }

        else 
        {
            // NO CROSSOVER? COPY SINGLE PARENT WITH MUTATION
            int PARENT = SELECTION(CURRENT);
            strcpy(NEW_POP[INDEX].CHROMOSOMES, CURRENT[PARENT].CHROMOSOMES);
            MUTATE(NEW_POP[INDEX].CHROMOSOMES);
            NEW_POP[INDEX].WELLBEING = FITNESS_CALC(NEW_POP[INDEX].CHROMOSOMES);
        
            if (INDEX + 1 < END) 
            {
                PARENT = SELECTION(CURRENT);
                strcpy(NEW_POP[INDEX + 1].CHROMOSOMES, CURRENT[PARENT].CHROMOSOMES);
                MUTATE(NEW_POP[INDEX + 1].CHROMOSOMES);
                NEW_POP[INDEX + 1].WELLBEING = FITNESS_CALC(NEW_POP[INDEX + 1].CHROMOSOMES);
            }
        }
    }
}

// HELPER FUNCTION TO BE ABLE TO COPY OVER THE NEW POPULATION FROM THE PREVIOUS
// THIS WILL ALWAYS PRESUPPOSE THAT THE PREVIOUS WERE THE OES WITH THE HIGHEST FITNESS

void COPY_POP(PERSON* SRC, PERSON* DEST, int SIZE)
{
    for(int INDEX = 0; INDEX < SIZE; INDEX++)
    {
        DEST[INDEX] = SRC[INDEX];
    }
}
