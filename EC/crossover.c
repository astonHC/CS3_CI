// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI EVOLUTIONARY COMPUTATION 

// THIS FILE PERTAINS TOWARDS AN EXAMPLE OF HOW UTILISING CROSSOVER
// ALLOWS FOR THE GRADUAL MUTATION/REPRODUCTION OF AN ALGORITHM OVER THE COURSE
// OF IT'S RUNTIME

// NESTED INCLUDES

#include "crossover.h"
#include "../util.h"

// CALCULATES THE COUNT MATCHING CHARACTERS AGAINST THE TARGET STRING
// THIS IS IN RELATION TO THE WELLNESS OF THE PERSON IN QUESTION
// THE WELLNESS WILL BE EXPANDED THROUGH THE EVOLUTION OF THE PROGRAM

int FITNESS_CALC(char* MATCH)
{
    int MATCHING_CHARS = 0;
    for(int INDEX = 0; INDEX < EC_STRLEN; INDEX++)
    {
        if(MATCH[INDEX] == EC_STRING[INDEX]) 
        { 
            MATCHING_CHARS++; 
        }
    }
    ERROR_TRACE(FITNESS, TRACE_OK, "FITNESS MATCH: %d", MATCHING_CHARS);
    return MATCHING_CHARS;
}

// CREATE A SINGLE POINT CROSSOVER WHICH CREATES TWO CHILDREN NODES 
// AGAINST THE PARENT
// THE CROSSOVER POINT IS THE POINT IN WHICH THE MUTATION WILL TAKE PLACE

int CROSS_SINGLE(char* PARENT_A, char* PARENT_B, char* CHILD_A, char* CHILD_B)
{
    int CROSS_POINT = 1 + rand() % (EC_STRLEN - 1);
    ERROR_TRACE(CROSS, TRACE_ERR_CROSSOVER, "SINGLE AT POINT %d", CROSS_POINT);

    // CREATE SUBSEQUENT NODES FOR CHILD USING MEMCPY FOR EFFICIENCY
    memcpy(CHILD_A, PARENT_A, CROSS_POINT);
    memcpy(CHILD_A + CROSS_POINT, PARENT_B + CROSS_POINT, EC_STRLEN - CROSS_POINT);

    memcpy(CHILD_B, PARENT_B, CROSS_POINT);
    memcpy(CHILD_B + CROSS_POINT, PARENT_A + CROSS_POINT, EC_STRLEN - CROSS_POINT);

    // ASSUME A NULL TERM CHARACTER TO AVOID SPILLOVERS
    CHILD_A[EC_STRLEN] = '\0';
    CHILD_B[EC_STRLEN] = '\0';

    return CROSS_POINT;
}

// CREATE A DOUBLE POINT CROSSOVER WHICH SWAPS SEGMENT BETWEEN TWO RANDOM POINTS
// THIS PROVIDES MORE GENETIC DIVERSITY THAN SINGLE POINT CROSSOVER

int CROSS_DOUBLE(char* PARENT_A, char* PARENT_B, char* CHILD_A, char* CHILD_B)
{
    int FIRST_POINT = rand() % EC_STRLEN;
    int SECOND_POINT = rand() % EC_STRLEN;

    if(FIRST_POINT > SECOND_POINT)
    {
        int TEMP = FIRST_POINT;
        FIRST_POINT = SECOND_POINT;
        SECOND_POINT = TEMP;
    }

    ERROR_TRACE(CROSS, TRACE_ERR_CROSSOVER, "DOUBLE BETWEEN %d AND %d", FIRST_POINT, SECOND_POINT);

    int SEGMENT_LENGTH = SECOND_POINT - FIRST_POINT + 1;

    // CREATE FIRST CHILD USING MEMCPY FOR EFFICIENT SEGMENT COPYING
    memcpy(CHILD_A, PARENT_A, FIRST_POINT);                                                         // FIRST SEGMENT
    memcpy(CHILD_A + FIRST_POINT, PARENT_B + FIRST_POINT, SEGMENT_LENGTH);                          // MIDDLE SEGMENT  
    memcpy(CHILD_A + SECOND_POINT + 1, PARENT_A + SECOND_POINT + 1, EC_STRLEN - SECOND_POINT - 1); // LAST SEGMENT

    // CREATE SECOND CHILD USING MEMCPY FOR EFFICIENT SEGMENT COPYING
    memcpy(CHILD_B, PARENT_B, FIRST_POINT);                                                         // FIRST SEGMENT
    memcpy(CHILD_B + FIRST_POINT, PARENT_A + FIRST_POINT, SEGMENT_LENGTH);                          // MIDDLE SEGMENT
    memcpy(CHILD_B + SECOND_POINT + 1, PARENT_B + SECOND_POINT + 1, EC_STRLEN - SECOND_POINT - 1); // LAST SEGMENT

    CHILD_A[EC_STRLEN] = '\0';
    CHILD_B[EC_STRLEN] = '\0';

    return SECOND_POINT - FIRST_POINT;
}
